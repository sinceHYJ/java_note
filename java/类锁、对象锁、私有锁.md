## 概念
> 1. 类锁：在代码中的方法上加了**static和synchronized**的锁，或者**synchronized(xxx.class）**的代码段
> 2. 对象锁：在代码中的方法上加了synchronized的锁，或者synchronized(this）的代码段
> 3. 私有锁：在类内部声明一个私有属性如private Object lock，在需要加锁的代码段synchronized(lock）



**类锁**与 **对象锁**的根本区别是锁的粒度，

## 对象锁

> 对象锁（synchronized修饰方法或代码块）

当一个对象中有synchronized method 或synchronized block 的时候，调用此对象的同步方法或进入其同步区域时，就必须先获得对象锁。

如果此对象的对象锁已被其他调用者占用，则需要等待此锁被释放。（方法锁也是对象锁）

java的所有对象都含有一个互斥锁，这个锁由jvm自动获取和释放。

线程进入synchronized 方法的时候获取该对象的锁，当然如果已经有线程获取了这个对象的锁，那么当前线程会等待；

synchronized方法正常返回或者抛异常而终止，jvm会自动释放对象锁。这里也体现了用synchronized来加锁的一个好处，即 ：

#### 方法锁抛异常时，锁仍然可以由jvm来释放。

<font color=green>注意对象锁锁住得是实例对象，若有多个实例对象，即便执行synchronized 方法，也不会同步！</font>



## 类锁

> 由于一个class不论被实例化多少次，其中的静态方法和静态变量在内存中都只有一份。所以，一旦一个静态的方法被声明为synchronized。此类所有的实例对象在调用此方法，共用同一把锁，我们称之为**类锁**。

### 对象锁是用来控制实例方法之间的同步，而类锁是用来控制静态方法（或者静态变量互斥体）之间的同步的。

类锁只是一个概念上的东西，并不是真实存在的，他只是用来帮助我们理解锁定实例方法和静态方法的区别的。
 java类可能会有很多对象，但是只有一个Class(字节码)对象，也就是说类的不同实例之间共享该类的Class对象。Class对象其实也仅仅是1个java对象，只不过有点特殊而已。

 由于每个java对象都有1个互斥锁，而类的静态方法是需要Class对象。所以所谓的类锁，只不过是Class对象的锁而已。

 获取类的Class对象的方法有好几种，最简单的是[类名.class]的方式。(百度：获取字节码的三种方式)

