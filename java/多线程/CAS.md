## CAS(compare and swap)是什么?

(宏观来说)在计算机科学中，比较和交换(CAS)是多线程中用于实现同步的原子指令(来自Wikipedia)。(回到现实来说)CAS中包含三个参数，内存中的值V、期望值A和要修改的值B。 拿期望值A与内存中的值V进行比较，如果相同，则用B替换内存中的值V，否则什么都不做。如果单线程的情况下，所有的操作都是一个线程来完成，就不需要考虑其他的问题。但是如果是多线程的话，同时访问内存就会有不一样的情况。

如果A、B线程能自觉的排队去访问主内存中的值就没这篇文章什么事了。 在某一时刻，线程A、B同时想去修改主内存中的共享变量。根据CAS原则有3个步骤要走，**读值比较替换**。它们同时读到了内存中的值V，并将值以期望值A的形式存到自己的工作内存(根据Java内存模型，每个线程有自己的工作内存来对变量进行操作)中。接着就是线程进行写值操作的时候了，内存中的值只有一个，若想操作它总要有个先来后到。若A线程眼疾手快抢占先机(假设这时并没有第三个线程改变内存中的值V)，用期望值A与内存中的值V比较，发现一致然后将自己的更新值B替换主内存的值V。然后线程B来了，在做比较的时候发现自己的期望值A与内存中的值V不相等，只能悻悻而归。



## CAS的优点

上面说到，volatile关键字不能保证原子性，开发过程中可以通过加锁的形式来保证。这里要鞭尸一波synchronized关键字，多线程的情况下，它能保证原子性。但是当一个线程获得锁后，其他线程就被挂起，当获得锁的线程释放锁后其他线程才能重新去竞争锁。每一次线程的阻塞和唤醒都需要操作系统的介入，需要在用户态和和内核态之间切换，而这种切换会消耗大量的系统资源。而使用CAS基于指令来实现，不需要进入内核或者切换线程，所以性能上会比synchronized关键字要好。



##### CAS的缺陷？

上面讲了它的有点，现在嘴臭一波。

1. CPU开销大
    在并发量大的情况下，CAS自旋的概率会变大。若多个线程反复的去尝试更新一个变量却一直不成功，会一直循环等待重试，直到耗尽CPU分配给该线程的时间片，对CPU造成巨大的压力。
2. 不能保证代码块的一致性
    CAS机制只能保证一个**变量**的原子性操作，多个变量时还是只能使用synchronized关键字。
3. ABA问题
    在线程读取变量和替换变量值的过程中存在一定的时间差，在这个时间差中内存中的变量值可能从A变成B再变成A，当前线程无法判断当前V值是否发生变化。对于如何解决这个ABA的问题，《并发编程艺术》中给出为每一个变量添加标识，一旦对变量的值修改后，对标识也进行操作。在每次CAS比较的过程中，同时去比较标识的值来判断当前的V值是否发生变化。Java提供了AtomicStampedReference来解决ABA的问题，它通过创建Pair内部对象来维护标记的引用。源码部分也还好理解的， 当前的引用和标识与预期的引用和标识相等，并且更新后的引用和标志与当前的引用和标志相等则直接返回true，否则通过生成一个新的Pair对象与当前Pair进行CAS替换。

