# 2. 线程安全性

## 2.1 状态

状态是指存储在该变量中的数据。

## 2.2 线程安全类

线程安全性指的是无论在何种情况下，都能够正确运行的程序。

线程安全的类指的是无论在何种情况下，都能够正确运行的类，线程安全的类不需要调用方在进行任何同步的操作。

## 2.3 竞态条件

**竞态条件**指的是在程序在不同执行顺序下表现出不同的行为。

一般有2中典型情况：

- **先检查后执行**：基于一个可能失效的结果来决定下一步的行动。

  典型情况如延迟初始化代码：

  ```java
  public class LazyInitrace {
      private ExpensiveObject instance = null;
      
      public ExpensiveObject getInstance() {
          if (instance == null) {
              instance = new ExpensiveObject();
          }
          return instance;
      }
  }
  ```


- **读取-修改-写入**：比如```++count```操作，基于对象之前的状态来定义对象状态的转换。

竞态条件并不总是会发生错误，还需要 **不正确的执行顺序**。

## 2.4 原子操作

原子操作指一组不可分的操作。我们称先检查后执行、读取-修改-写入为复合操作。

在现实情况中应尽可能使用现有的线程安全的类、对象。

**要保持状态的一致性，就必须在原子操作中更新所有有关的状态变量。**

## 2.5 加锁机制

在java程序中使用synchronized关键字来实现加锁机制。被加锁的代码由并行变为串行。

每个java对象都有一个锁，成为**内置锁。**

内置锁是可重入的，目前理解的重入的概念是该加锁的对象可继续执行其他加锁方法。

这意味着获取锁的操作粒度是线程，而非“调用”。

## 2.6 用锁来保护状态

对象中的所有状态变量应该都由同一个锁来保护，以便开发人员指导是哪个锁。

java中许多将状态变量的操作封装在类中，并通过内置锁来实现同步，java中的许多线程安全的集合框架就使用了这种模式。

## 2.7 性能

使用同步不可避免的会降低性能。

我们需要将synchronized的代码变得尽量小，只保证状态变量的操作是线程安全的。

同时我们注意耗时的操作：比如计算时间较长的操作，IO，等待控制台输入等，一定不要放在同步代码块中，否则会大大降低性能。

