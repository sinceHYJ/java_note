#### 1. hash函数计算原理
这段代码叫“**扰动函数**”
```java
static final int hash(Object key) {
        int h;
        return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
}
```
大家都知道上面代码里的key.hashCode()函数调用的是key键值类型自带的哈希函数，返回int型散列值。考虑到2进制32位带符号的int表值范围从-2147483648到2147483648。

**HashMap的数组默认大小为16，并且每次扩容，大小均为2的幂次方。**

我们不可能使用40亿的数组存储，所以需要对数组的长度进行**取模**；代码中使用位与（&）进行取模操作。

```java
(n - 1) & hash
```

![image](F90CE0C7D4334131BD09FC70C205A7DB)

但是即便hash值分部在松散，如果只是取后几位，碰撞率也会很高。

这时候**扰动函数**的价值就体现出来了。

![image](1ED3E073684444E09308C9182C22384A)

**左移16位，正好是32bit的一半，自己的高半区与低半区异或，就是为了混合原始哈希码的高位和地位，一次来加大低位的随机性，混合后的低位掺杂了高位的部分特征，这样高位的信息也被变相保留下来。**