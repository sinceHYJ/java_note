# 1.选择原则
## 1.1 更小的通常更好

但是要确保没有低估存储数据的范围，因为增加数据范围是一个非常耗时和痛苦的操作

## 1.2 简单就好

## 1.3 尽量避免NULL
如果打算在该列上建立索引，则应当避免NULL。

# 2.数据类型
## 2.1 整数
tinyint(1)、smallint（2）、mediumint（3）、int（4）、bigint（8）。
范围：-2^(N-1)到2^(N-1)。若无符号，则范围可扩大一倍。

**注意**：int（1）括号内的为指定的宽度。但是这丝毫不影响该类型存储值的范围，只是对与一些交互工具，用来显示字符的个数。

## 2.2 实数类型
Float（4）、double（8）为浮点数，计算过程中更可能会丢失精度。计算过程中使用double计算。

Decimal为精确存储，DECIMAL类型允许存储最多65个数字。使用4字节存储9个数字（压缩过的），例如：Decimal(18,9)小数点两边各存储9各数字，i 个使用9各字节，小数点占用1各字节。

因为需要额外的空间和计算开销，所以在实际应用中，应尽量在只对小数进行精确计算的时候才使用DECIMAL。在有金额交易的实战过程中，更倾向于使用BIGINT代替DECIMAL，将金额单位扩大相应倍数，如金额单位为元，而在存储的时候扩大100倍，使用分为单位，这样可以避免使用浮点数计算不精确的问题和使用DECIMAL计算代价高的问题。

## 2.3 字符串类型 varchar char

varchar为变长字符串存储，当长度小于255字节时，使用1字节来存储长度，当长度大于255字节时，使用2字节来保存长度。

**缺点**：由于行是变长的，在update时候，会导致额外的工作。

**使用场景**：
1. 当字串的最大长度远大于平均长度。
2. 更新较少，碎片不是问题。
3. 使用了UTF-8编码，每个字符使用不同字节存储。


char，定长，字符串不够时，补空格。

但在保存时，会默认去掉字符串最后的空格。

因为长度固定，所以不会产生碎片问题。对于短的列使用char存储更有效率，
例如使用char(1)存储Y、N，比varchar更好，因为varchar还会用1byte存储长度。

**使用场景**：
1. 定长字符串，比如uuid，32位时。
2. 存储短的信息。
3. 更新操作多时，varchar需要额外的操作。


## 2.4 BLOB 、TEXT 
这两种都是用来存储很大的数据设计的。不同的是**BLOB（二进制）**和**TEXT（字符串）**。

他们都有类似的TINYTEXT SMALLTEXT MEDIUMTEXT LONGTEXT

TINYBLOB SMALLBLOB MEDIUMBLOB LONGBLOB.

当数据太长的时候，他们会使用“外部”的存储空间，此时存储的1-4byte的指针。

BLOB没有编码及校对规则。

## 2.5 枚举
枚举在数据库中会被保存为整数，存储的.frm文件中保存这数字-字符串的影射关系的查找表。因此枚举是按照整数排序的而不是字符串。

**缺点**：枚举类型在更改时候必须使用alter table操作。

## 2.6 日期
日期有2中类型：datetime、timestamp
datetime使用8byte的字符串保存，无时区概念。精确到秒。

timestamp本质是从1970年来时间差，具有时区的概念。使用4字节保存，范围从1970-2038年。

它们之间互相转换的函数：from_unixtime()  unix_timestamp()

## 2.7 位类型
bit代表1各字节位，可以使用bit(1)定义一个包含单个位的字段。

bit被mysql当作**字符串**类型，而非数字类型，因此查询出来的是字串的0、1，而非ASCII码0 1.

然而在数字上下文中检索时，是将字符串转化为数字。

如果需要和其他值进行比较是，例如b'00111001在数字上下位中是数字57。




